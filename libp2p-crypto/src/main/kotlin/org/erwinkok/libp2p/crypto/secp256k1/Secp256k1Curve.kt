// Copyright (c) 2022-2023 Erwin Kok. BSD-3-Clause license. See LICENSE file for more details.
package org.erwinkok.libp2p.crypto.secp256k1

import mu.KotlinLogging
import org.erwinkok.libp2p.crypto.ecdsa.CurvePoint
import org.erwinkok.libp2p.crypto.math.BigInt
import org.erwinkok.util.Tuple
import org.erwinkok.util.Tuple2
import java.io.ByteArrayInputStream
import java.io.IOException
import java.math.BigInteger
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.Base64
import java.util.zip.InflaterInputStream
import kotlin.math.max

private val logger = KotlinLogging.logger {}

object Secp256k1Curve {
    val endomorphismLambda = BigInt.fromHex("5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72")
    val endomorphismBeta = FieldVal.fromHex("7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    val endomorphismA1 = BigInt.fromHex("3086d221a7d46bcde86c90e49284eb15")
    val endomorphismB1 = BigInt.fromHex("-e4437ed6010e88286f547fa90abfe4c3")
    val endomorphismA2 = BigInt.fromHex("114ca50f7a8e2f3f657c1108d9d44cfd8")
    val endomorphismB2 = BigInt.fromHex("3086d221a7d46bcde86c90e49284eb15")

    val p = BigInt.fromHex("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f") // P is the prime used in the secp256k1 field.
    val n = BigInt.fromHex("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141") // N is the order of the secp256k1 curve group generated by the base point.
    val g = CurvePoint(
        BigInt.fromHex("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), // Gx is the x coordinate of the base point.
        BigInt.fromHex("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8") // Gy is the y coordinate of the base point.
    )
    val bitSize = 256 // the size of the underlying field   // BitSize is the size of the underlying secp256k1 field in bits.
    val h = 1 // H is the cofactor of the secp256k1 curve.
    val byteSize = 256 / 8 // ByteSize is simply the bit size / 8 and is provided for convenience since it is calculated repeatedly.

    val byte2dPoints: List<List<Jacobian2dPoint>> by lazy { initS256BytePoints() }

    // addZ1AndZ2EqualsOne adds two Jacobian points that are already known to have
    // z values of 1 and stores the result in (x3, y3, z3).  That is to say
    // (x1, y1, 1) + (x2, y2, 1) = (x3, y3, z3).  It performs faster addition than
    // the generic add routine since less arithmetic is needed due to the ability to
    // avoid the z value multiplications.
    private fun addZ1AndZ2EqualsOne(p1: JacobianPoint, p2: JacobianPoint): JacobianPoint {
        // To compute the point addition efficiently, this implementation splits
        // the equation into intermediate elements which are used to minimize
        // the number of field multiplications using the method shown at:
        // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-mmadd-2007-bl
        //
        // In particular it performs the calculations using the following:
        // H = X2-X1, HH = H^2, I = 4*HH, J = H*I, r = 2*(Y2-Y1), V = X1*I
        // X3 = r^2-J-2*V, Y3 = r*(V-X3)-2*Y1*J, Z3 = 2*H
        //
        // This results in a cost of 4 field multiplications, 2 field squarings,
        // 6 field additions, and 5 integer multiplications.

        // When the x coordinates are the same for two points on the curve, the
        // y coordinates either must be the same, in which case it is point
        // doubling, or they are opposite and the result is the point at
        // infinity per the group law for elliptic curve cryptography.
        if (p1.x == p2.x) {
            if (p1.y == p2.y) {
                // Since x1 == x2 and y1 == y2, point doubling must be
                // done, otherwise the addition would end up dividing
                // by zero.
                return doubleNonConst(p1)
            }

            // Since x1 == x2 and y1 == -y2, the sum is the point at
            // infinity per the group law.
            return JacobianPoint.Zero
        }

        // Calculate X3, Y3, and Z3 according to the intermediate elements
        // breakdown above.
        val h = -p1.x + p2.x // H = X2-X1 (mag: 3)
        val i = h.square() * 4 // I = 4*H^2 (mag: 4)
        val j = h * i // J = H*I (mag: 1)
        val r = (-p1.y + p2.y) * 2 // r = 2*(Y2-Y1) (mag: 6)
        val v = p1.x * i // V = X1*I (mag: 1)
        val negJ = -j // negJ = -J (mag: 2)
        val neg2V = (v * 2).negate(2) // neg2V = -(2*V) (mag: 3)
        val x3 = r.square() + negJ + neg2V // X3 = r^2-J-2*V (mag: 6)
        val negX3 = x3.negate(6) // negX3 = -X3 (mag: 7)
        val y3 = ((v + negX3) * r) + (j * p1.y * 2).negate(2) // Y3 = r*(V-X3)-2*Y1*J (mag: 4)
        val z3 = h * 2 // Z3 = 2*H (mag: 6)

        // Normalize the resulting field values to a magnitude of 1 as needed.
        return JacobianPoint(x3.normalize(), y3.normalize(), z3.normalize())
    }

    // addZ1EqualsZ2 adds two Jacobian points that are already known to have the
    // same z value and stores the result in (x3, y3, z3).  That is to say
    // (x1, y1, z1) + (x2, y2, z1) = (x3, y3, z3).  It performs faster addition than
    // the generic add routine since less arithmetic is needed due to the known
    // equivalence.
    private fun addZ1EqualsZ2(p1: JacobianPoint, p2: JacobianPoint): JacobianPoint {
        // To compute the point addition efficiently, this implementation splits
        // the equation into intermediate elements which are used to minimize
        // the number of field multiplications using a slightly modified version
        // of the method shown at:
        // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-mmadd-2007-bl
        //
        // In particular it performs the calculations using the following:
        // A = X2-X1, B = A^2, C=Y2-Y1, D = C^2, E = X1*B, F = X2*B
        // X3 = D-E-F, Y3 = C*(E-X3)-Y1*(F-E), Z3 = Z1*A
        //
        // This results in a cost of 5 field multiplications, 2 field squarings,
        // 9 field additions, and 0 integer multiplications.

        // When the x coordinates are the same for two points on the curve, the
        // y coordinates either must be the same, in which case it is point
        // doubling, or they are opposite and the result is the point at
        // infinity per the group law for elliptic curve cryptography.
        if (p1.x == p2.x) {
            if (p1.y == p2.y) {
                // Since x1 == x2 and y1 == y2, point doubling must be
                // done, otherwise the addition would end up dividing
                // by zero.
                return doubleNonConst(p1)
            }

            // Since x1 == x2 and y1 == -y2, the sum is the point at
            // infinity per the group law.
            return JacobianPoint.Zero
        }

        // Calculate X3, Y3, and Z3 according to the intermediate elements
        // breakdown above.
        val negX1 = -p1.x // negX1 = -X1 (mag: 2)
        val negY1 = -p1.y // negY1 = -Y1 (mag: 2)
        val a = negX1 + p2.x // A = X2-X1 (mag: 3)
        val b = a.square() // B = A^2 (mag: 1)
        val c = negY1 + p2.y // C = Y2-Y1 (mag: 3)
        val d = c.square() // D = C^2 (mag: 1)
        val e = p1.x * b // E = X1*B (mag: 1)
        val negE = -e // negE = -E (mag: 2)
        val f = p2.x * b // F = X2*B (mag: 1)
        val x3 = (e + f).negate(2) + d // X3 = D-E-F (mag: 5)
        val negX3 = x3.negate(4) // negX3 = -X3 (mag: 1)
        var y3 = (p1.y * (f + negE)).negate(1) // Y3 = -(Y1*(F-E)) (mag: 2)
        y3 += ((e + negX3) * c) // Y3 = C*(E-X3)+Y3 (mag: 3)
        val z3 = p1.z * a // Z3 = Z1*A (mag: 1)

        // Normalize the resulting field values to a magnitude of 1 as needed.
        return JacobianPoint(x3.normalize(), y3.normalize(), z3.normalize())
    }

    // addZ2EqualsOne adds two Jacobian points when the second point is already
    // known to have a z value of 1 (and the z value for the first point is not 1)
    // and stores the result in (x3, y3, z3).  That is to say (x1, y1, z1) +
    // (x2, y2, 1) = (x3, y3, z3).  It performs faster addition than the generic
    // add routine since less arithmetic is needed due to the ability to avoid
    // multiplications by the second point's z value.
    private fun addZ2EqualsOne(p1: JacobianPoint, p2: JacobianPoint): JacobianPoint {
        // To compute the point addition efficiently, this implementation splits
        // the equation into intermediate elements which are used to minimize
        // the number of field multiplications using the method shown at:
        // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-madd-2007-bl
        //
        // In particular it performs the calculations using the following:
        // Z1Z1 = Z1^2, U2 = X2*Z1Z1, S2 = Y2*Z1*Z1Z1, H = U2-X1, HH = H^2,
        // I = 4*HH, J = H*I, r = 2*(S2-Y1), V = X1*I
        // X3 = r^2-J-2*V, Y3 = r*(V-X3)-2*Y1*J, Z3 = (Z1+H)^2-Z1Z1-HH
        //
        // This results in a cost of 7 field multiplications, 4 field squarings,
        // 9 field additions, and 4 integer multiplications.

        // When the x coordinates are the same for two points on the curve, the
        // y coordinates either must be the same, in which case it is point
        // doubling, or they are opposite and the result is the point at
        // infinity per the group law for elliptic curve cryptography.  Since
        // any number of Jacobian coordinates can represent the same affine
        // point, the x and y values need to be converted to like terms.  Due to
        // the assumption made for this function that the second point has a z
        // value of 1 (z2=1), the first point is already "converted".
        val z1z1 = p1.z.square() // Z1Z1 = Z1^2 (mag: 1)
        val u2 = (p2.x * z1z1).normalize() // U2 = X2*Z1Z1 (mag: 1)
        val s2 = (p2.y * z1z1 * p1.z).normalize() // S2 = Y2*Z1*Z1Z1 (mag: 1)
        if (p1.x == u2) {
            if (p1.y == s2) {
                // Since x1 == x2 and y1 == y2, point doubling must be
                // done, otherwise the addition would end up dividing
                // by zero.
                return doubleNonConst(p1)
            }

            // Since x1 == x2 and y1 == -y2, the sum is the point at
            // infinity per the group law.
            return JacobianPoint.Zero
        }

        // Calculate X3, Y3, and Z3 according to the intermediate elements
        // breakdown above.
        val negX1 = -p1.x // negX1 = -X1 (mag: 2)
        val h = u2 + negX1 // H = U2-X1 (mag: 3)
        val hh = h.square() // HH = H^2 (mag: 1)
        val i = hh * 4 // I = 4 * HH (mag: 4)
        val j = h * i // J = H*I (mag: 1)
        val negY1 = -p1.y // negY1 = -Y1 (mag: 2)
        val r = (s2 + negY1) * 2 // r = 2*(S2-Y1) (mag: 6)
        val rr = r.square() // rr = r^2 (mag: 1)
        val v = p1.x * i // V = X1*I (mag: 1)
        var x3 = ((v * 2) + j).negate(3) // X3 = -(J+2*V) (mag: 4)
        x3 += rr // X3 = r^2+X3 (mag: 5)
        val negX3 = x3.negate(5) // negX3 = -X3 (mag: 6)
        var y3 = ((p1.y * j) * 2).negate(2) // Y3 = -(2*Y1*J) (mag: 3)
        y3 += ((v + negX3) * r) // Y3 = r*(V-X3)+Y3 (mag: 4)
        var z3 = (p1.z + h).square() // Z3 = (Z1+H)^2 (mag: 1)
        z3 += ((z1z1 + hh).negate(2)) // Z3 = Z3-(Z1Z1+HH) (mag: 4)

        // Normalize the resulting field values to a magnitude of 1 as needed.
        return JacobianPoint(x3.normalize(), y3.normalize(), z3.normalize())
    }

    // addGeneric adds two Jacobian points (x1, y1, z1) and (x2, y2, z2) without any
    // assumptions about the z values of the two points and stores the result in
    // (x3, y3, z3).  That is to say (x1, y1, z1) + (x2, y2, z2) = (x3, y3, z3).  It
    // is the slowest of the add routines due to requiring the most arithmetic.
    private fun addGeneric(p1: JacobianPoint, p2: JacobianPoint): JacobianPoint {
        // To compute the point addition efficiently, this implementation splits
        // the equation into intermediate elements which are used to minimize
        // the number of field multiplications using the method shown at:
        // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl
        //
        // In particular it performs the calculations using the following:
        // Z1Z1 = Z1^2, Z2Z2 = Z2^2, U1 = X1*Z2Z2, U2 = X2*Z1Z1, S1 = Y1*Z2*Z2Z2
        // S2 = Y2*Z1*Z1Z1, H = U2-U1, I = (2*H)^2, J = H*I, r = 2*(S2-S1)
        // V = U1*I
        // X3 = r^2-J-2*V, Y3 = r*(V-X3)-2*S1*J, Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H
        //
        // This results in a cost of 11 field multiplications, 5 field squarings,
        // 9 field additions, and 4 integer multiplications.

        // When the x coordinates are the same for two points on the curve, the
        // y coordinates either must be the same, in which case it is point
        // doubling, or they are opposite and the result is the point at
        // infinity.  Since any number of Jacobian coordinates can represent the
        // same affine point, the x and y values need to be converted to like
        // terms.
        val z1z1 = p1.z.square() // Z1Z1 = Z1^2 (mag: 1)
        val z2z2 = p2.z.square() // Z2Z2 = Z2^2 (mag: 1)
        val u1 = (p1.x * z2z2).normalize() // U1 = X1*Z2Z2 (mag: 1)
        val u2 = (p2.x * z1z1).normalize() // U2 = X2*Z1Z1 (mag: 1)
        val s1 = (p1.y * z2z2 * p2.z).normalize() // S1 = Y1*Z2*Z2Z2 (mag: 1)
        val s2 = (p2.y * z1z1 * p1.z).normalize() // S2 = Y2*Z1*Z1Z1 (mag: 1)
        if (u1 == u2) {
            if (s1 == s2) {
                // Since x1 == x2 and y1 == y2, point doubling must be
                // done, otherwise the addition would end up dividing
                // by zero.
                return doubleNonConst(p1)
            }

            // Since x1 == x2 and y1 == -y2, the sum is the point at
            // infinity per the group law.
            return JacobianPoint.Zero
        }

        // Calculate X3, Y3, and Z3 according to the intermediate elements
        // breakdown above.
        val negU1 = -u1 // negU1 = -U1 (mag: 2)
        val h = u2 + negU1 // H = U2-U1 (mag: 3)
        val i = (h * 2).square() // I = (2*H)^2 (mag: 2)
        val j = h * i // J = H*I (mag: 1)
        val negS1 = -s1 // negS1 = -S1 (mag: 2)
        val r = (s2 + negS1) * 2 // r = 2*(S2-S1) (mag: 6)
        val rr = r.square() // rr = r^2 (mag: 1)
        val v = u1 * i // V = U1*I (mag: 1)
        var x3 = (v * 2 + j).negate(3) // X3 = -(J+2*V) (mag: 4)
        x3 += rr // X3 = r^2+X3 (mag: 5)
        val negX3 = x3.negate(5) // negX3 = -X3 (mag: 6)
        var y3 = (s1 * j * 2).negate(2) // Y3 = -(2*S1*J) (mag: 3)
        y3 += ((v + negX3) * r) // Y3 = r*(V-X3)+Y3 (mag: 4)
        var z3 = (p1.z + p2.z).square() // Z3 = (Z1+Z2)^2 (mag: 1)
        z3 += ((z1z1 + z2z2).negate(2)) // Z3 = Z3-(Z1Z1+Z2Z2) (mag: 4)
        z3 *= h // Z3 = Z3*H (mag: 1)

        // Normalize the resulting field values to a magnitude of 1 as needed.
        return JacobianPoint(x3.normalize(), y3.normalize(), z3.normalize())
    }

    // addJacobian adds the passed Jacobian points (x1, y1, z1) and (x2, y2, z2)
    // together and stores the result in (x3, y3, z3).
    fun addNonConst(p1: JacobianPoint, p2: JacobianPoint): JacobianPoint {
        // A point at infinity is the identity according to the group law for
        // elliptic curve cryptography.  Thus, ∞ + P = P and P + ∞ = P.
        if (p1.x.isZero && p1.y.isZero || p1.z.isZero) {
            return p2
        }

        if (p2.x.isZero && p2.y.isZero || p2.z.isZero) {
            return p1
        }

        // Faster point addition can be achieved when certain assumptions are
        // met.  For example, when both points have the same z value, arithmetic
        // on the z values can be avoided.  This section thus checks for these
        // conditions and calls an appropriate add function which is accelerated
        // by using those assumptions.
        val isZ1One = p1.z.isOne
        val isZ2One = p2.z.isOne
        if (isZ1One && isZ2One) {
            return addZ1AndZ2EqualsOne(p1, p2)
        } else if (p1.z == p2.z) {
            return addZ1EqualsZ2(p1, p2)
        } else if (isZ2One) {
            return addZ2EqualsOne(p1, p2)
        }

        // None of the above assumptions are true, so fall back to generic
        // point addition.
        return addGeneric(p1, p2)
    }

    // doubleZ1EqualsOne performs point doubling on the passed Jacobian point
    // when the point is already known to have a z value of 1 and stores
    // the result in (x3, y3, z3).  That is to say (x3, y3, z3) = 2*(x1, y1, 1).  It
    // performs faster point doubling than the generic routine since less arithmetic
    // is needed due to the ability to avoid multiplication by the z value.
    private fun doubleZ1EqualsOne(p: JacobianPoint): JacobianPoint {
        // This function uses the assumptions that z1 is 1, thus the point
        // doubling formulas reduce to:
        //
        // X3 = (3*X1^2)^2 - 8*X1*Y1^2
        // Y3 = (3*X1^2)*(4*X1*Y1^2 - X3) - 8*Y1^4
        // Z3 = 2*Y1
        //
        // To compute the above efficiently, this implementation splits the
        // equation into intermediate elements which are used to minimize the
        // number of field multiplications in favor of field squarings which
        // are roughly 35% faster than field multiplications with the current
        // implementation at the time this was written.
        //
        // This uses a slightly modified version of the method shown at:
        // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-mdbl-2007-bl
        //
        // In particular it performs the calculations using the following:
        // A = X1^2, B = Y1^2, C = B^2, D = 2*((X1+B)^2-A-C)
        // E = 3*A, F = E^2, X3 = F-2*D, Y3 = E*(D-X3)-8*C
        // Z3 = 2*Y1
        //
        // This results in a cost of 1 field multiplication, 5 field squarings,
        // 6 field additions, and 5 integer multiplications.
        val z3 = p.y * 2 // Z3 = 2*Y1 (mag: 2)
        val a = p.x.square() // A = X1^2 (mag: 1)
        var b = p.y.square() // B = Y1^2 (mag: 1)
        val c = b.square() // C = B^2 (mag: 1)
        b = (b + p.x).square() // B = (X1+B)^2 (mag: 1)
        var d = (a + c).negate(2) // D = -(A+C) (mag: 3)
        d = (d + b) * 2 // D = 2*(B+D)(mag: 8)
        val e = a * 3 // E = 3*A (mag: 3)
        var f = e.square() // F = E^2 (mag: 1)
        var x3 = (d * 2).negate(16) // X3 = -(2*D) (mag: 17)
        x3 += f // X3 = F+X3 (mag: 18)
        f = (x3.negate(18) + d).normalize() // F = D-X3 (mag: 1)
        var y3 = (c * 8).negate(8) // Y3 = -(8*C) (mag: 9)
        y3 += (f * e) // Y3 = E*F+Y3 (mag: 10)

        // Normalize the field values back to a magnitude of 1.
        return JacobianPoint(x3.normalize(), y3.normalize(), z3.normalize())
    }

    // doubleGeneric performs point doubling on the passed Jacobian point without
    // any assumptions about the z value and stores the result in (x3, y3, z3).
    // That is to say (x3, y3, z3) = 2*(x1, y1, z1).  It is the slowest of the point
    // doubling routines due to requiring the most arithmetic.
    private fun doubleGeneric(p: JacobianPoint): JacobianPoint {
        // Point doubling formula for Jacobian coordinates for the secp256k1
        // curve:
        // X3 = (3*X1^2)^2 - 8*X1*Y1^2
        // Y3 = (3*X1^2)*(4*X1*Y1^2 - X3) - 8*Y1^4
        // Z3 = 2*Y1*Z1
        //
        // To compute the above efficiently, this implementation splits the
        // equation into intermediate elements which are used to minimize the
        // number of field multiplications in favor of field squarings which
        // are roughly 35% faster than field multiplications with the current
        // implementation at the time this was written.
        //
        // This uses a slightly modified version of the method shown at:
        // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
        //
        // In particular it performs the calculations using the following:
        // A = X1^2, B = Y1^2, C = B^2, D = 2*((X1+B)^2-A-C)
        // E = 3*A, F = E^2, X3 = F-2*D, Y3 = E*(D-X3)-8*C
        // Z3 = 2*Y1*Z1
        //
        // This results in a cost of 1 field multiplication, 5 field squarings,
        // 6 field additions, and 5 integer multiplications.
        val z3 = p.y * p.z * 2 // Z3 = 2*Y1*Z1 (mag: 2)
        val a = p.x.square() // A = X1^2 (mag: 1)
        var b = p.y.square() // B = Y1^2 (mag: 1)
        val c = b.square() // C = B^2 (mag: 1)
        b = (b + p.x).square() // B = (X1+B)^2 (mag: 1)
        var d = (a + c).negate(2) // D = -(A+C) (mag: 3)
        d = (d + b) * 2 // D = 2*(B+D)(mag: 8)
        val e = a * 3 // E = 3*A (mag: 3)
        var f = e.square() // F = E^2 (mag: 1)
        var x3 = (d * 2).negate(16) // X3 = -(2*D) (mag: 17)
        x3 += f // X3 = F+X3 (mag: 18)
        f = (x3.negate(18) + d).normalize() // F = D-X3 (mag: 1)
        var y3 = (c * 8).negate(8) // Y3 = -(8*C) (mag: 9)
        y3 += (f * e) // Y3 = E*F+Y3 (mag: 10)

        // Normalize the field values back to a magnitude of 1.
        return JacobianPoint(x3.normalize(), y3.normalize(), z3.normalize())
    }

    // doubleJacobian doubles the passed Jacobian point (x1, y1, z1) and stores the
    // result in (x3, y3, z3).
    // NOTE: The point must be normalized for this function to return the correct result.
    // The resulting point will be normalized.
    fun doubleNonConst(p: JacobianPoint): JacobianPoint {
        // Doubling a point at infinity is still infinity.
        if (p.y.isZero || p.z.isZero) {
            return JacobianPoint.Zero
        }

        // Slightly faster point doubling can be achieved when the z value is 1
        // by avoiding the multiplication on the z value.  This section calls
        // a point doubling function which is accelerated by using that
        // assumption when possible.
        if (p.z.isOne) {
            return doubleZ1EqualsOne(p)
        }

        // Fall back to generic point doubling which works with arbitrary z
        // values.
        return doubleGeneric(p)
    }

    // splitK returns a balanced length-two representation of k and their signs.
    // This is algorithm 3.74 from [GECC].
    //
    // One thing of note about this algorithm is that no matter what c1 and c2 are,
    // the final equation of k = k1 + k2 * lambda (mod n) will hold.  This is
    // provable mathematically due to how a1/b1/a2/b2 are computed.
    //
    // c1 and c2 are chosen to minimize the max(k1,k2).
    fun splitK(k: ByteArray): SplitK {
        // All math here is done with BigInteger, which is slow.
        // At some point, it might be useful to write something similar to
        // fieldVal but for N instead of P as the prime field if this ends up
        // being a bottleneck.
        val bigIntK = BigInt.fromBytes(k)

        // c1 = round(b2 * k / n) from step 4.
        // Rounding isn't really necessary and costs too much, hence skipped
        var c1 = endomorphismB2.multiply(bigIntK)
        c1 = c1.divide(n)
        // c2 = round(b1 * k / n) from step 4 (sign reversed to optimize one step)
        // Rounding isn't really necessary and costs too much, hence skipped
        var c2 = endomorphismB1.multiply(bigIntK)
        c2 = c2.divide(n).subtract(BigInteger.ONE)
        // k1 = k - c1 * a1 - c2 * a2 from step 5 (note c2's sign is reversed)
        var tmp1 = c1.multiply(endomorphismA1)
        var tmp2 = c2.multiply(endomorphismA2)
        var k1 = bigIntK.subtract(tmp1)
        k1 = k1.add(tmp2)
        // k2 = - c1 * b1 - c2 * b2 from step 5 (note c2's sign is reversed)
        tmp1 = c1.multiply(endomorphismB1)
        tmp2 = c2.multiply(endomorphismB2)
        val k2 = tmp2.subtract(tmp1)
        // Note Bytes() throws out the sign of k1 and k2. This matters
        // since k1 and/or k2 can be negative. Hence, we pass that
        // back separately.
        return SplitK(BigInt.toBytes(k1.abs()), BigInt.toBytes(k2.abs()), k1.signum(), k2.signum())
    }

    // naf takes a positive integer up to a maximum value of 2^256 - 1 and returns
    // its non-adjacent form (NAF), which is a unique signed-digit representation
    // such that no two consecutive digits are nonzero.  See the documentation for
    // the returned type for details on how the representation is encoded
    // efficiently and how to interpret it
    //
    // NAF is useful in that it has the fewest nonzero digits of any signed digit
    // representation, only 1/3rd of its digits are nonzero on average, and at least
    // half of the digits will be 0.
    //
    // The aforementioned properties are particularly beneficial for optimizing
    // elliptic curve point multiplication because they effectively minimize the
    // number of required point additions in exchange for needing to perform a mix
    // of fewer point additions and subtractions and possibly one additional point
    // doubling.  This is an excellent tradeoff because subtraction of points has
    // the same computational complexity as addition of points and point doubling is
    // faster than both.
    fun naf(k: ByteArray): NafScalar {
        var len = k.size
        var index = 0

        // Strip leading zero bytes.
        while (len > 0 && k[index] == 0.toByte()) {
            len--
            index++
        }

        // The non-adjacent form (NAF) of a positive integer k is an expression
        // k = ∑_(i=0, l-1) k_i * 2^i where k_i ∈ {0,±1}, k_(l-1) != 0, and no two
        // consecutive digits k_i are nonzero.
        //
        // The traditional method of computing the NAF of a positive integer is
        // given by algorithm 3.30 in [GECC].  It consists of repeatedly dividing k
        // by 2 and choosing the remainder so that the quotient (k−r)/2 is even
        // which ensures the next NAF digit is 0.  This requires log_2(k) steps.
        //
        // However, in [BRID], Prodinger notes that a closed form expression for the
        // NAF representation is the bitwise difference 3k/2 - k/2.  This is more
        // efficient as it can be computed in O(1) versus the O(log(n)) of the
        // traditional approach.
        //
        // The following code makes use of that formula to compute the NAF more
        // efficiently.
        //
        // To understand the logic here, observe that the only way the NAF has a
        // nonzero digit at a given bit is when either 3k/2 or k/2 has a bit set in
        // that position, but not both.  In other words, the result of a bitwise
        // xor.  This can be seen simply by considering that when the bits are the
        // same, the subtraction is either 0-0 or 1-1, both of which are 0.
        //
        // Further, observe that the "+1" digits in the result are contributed by
        // 3k/2 while the "-1" digits are from k/2.  So, they can be determined by
        // taking the bitwise and of each respective value with the result of the
        // xor which identifies which bits are nonzero.
        //
        // Using that information, this loops backwards from the least significant
        // byte to the most significant byte while performing the aforementioned
        // calculations by propagating the potential carry and high order bit from
        // the next word during the right shift.
        var carry: UByte = 0u
        val pos = ByteArray(33)
        val neg = ByteArray(33)
        for (byteNum in len - 1 downTo 0) {
            // Calculate k/2.  Notice the carry from the previous word is added and
            // the low order bit from the next word is shifted in accordingly.
            val kc = k[index + byteNum].toUByte().toUShort() + carry.toUShort()
            val nextWord = if (byteNum > 0) {
                k[index + byteNum - 1].toUByte().toUInt()
            } else {
                0u
            }
            val halfK = (kc shr 1) or ((nextWord and 1u) shl 7)

            // Calculate 3k/2 and determine the non-zero digits in the result.
            val threeHalfK = kc + halfK
            val nonZeroResultDigits = threeHalfK xor halfK

            // Determine the signed digits {0, ±1}.
            pos[byteNum + 1] = (threeHalfK and nonZeroResultDigits).toByte()
            neg[byteNum + 1] = (halfK and nonZeroResultDigits).toByte()

            // Propagate the potential carry from the 3k/2 calculation.
            carry = (threeHalfK shr 8).toUByte()
        }
        pos[0] = carry.toByte()

        // Set the starting and ending positions within the fixed size arrays to
        // identify the bytes that are actually used.  This is important since the
        // encoding is big endian and thus trailing zero bytes changes its value.
        return if (carry > 0u) {
            val rpos = ByteArray(len + 1)
            val rneg = ByteArray(len + 1)
            System.arraycopy(pos, 0, rpos, 0, len + 1)
            System.arraycopy(neg, 0, rneg, 0, len + 1)
            NafScalar(rpos, rneg)
        } else {
            val rpos = ByteArray(len)
            val rneg = ByteArray(len)
            System.arraycopy(pos, 1, rpos, 0, len)
            System.arraycopy(neg, 1, rneg, 0, len)
            NafScalar(rpos, rneg)
        }
    }

    // ScalarMultNonConst multiplies k*P where k is a big endian integer modulo the
    // curve order and P is a point in Jacobian projective coordinates and stores
    // the result in the provided Jacobian point.
    //
    // NOTE: The point must be normalized for this function to return the correct
    // result.  The resulting point will be normalized.
    fun scalarMultNonConst(k: ModNScalar, point: JacobianPoint): JacobianPoint {
        // Decompose K into k1 and k2 in order to halve the number of EC ops.
        // See Algorithm 3.74 in [GECC].
        val kBytes = k.bytes()
        val (k1, k2, signK1, signK2) = splitK(kBytes)

        // The main equation here to remember is:
        //   k * P = k1 * P + k2 * ϕ(P)
        //
        // P1 below is P in the equation, P2 below is ϕ(P) in the equation
        var p1 = point
        var p1Neg = JacobianPoint(p1.x, p1.y.negate(1).normalize(), p1.z)

        // NOTE: ϕ(x,y) = (βx,y).  The Jacobian z coordinates are the same, so this
        // math goes through.
        var p2 = JacobianPoint((point.x * endomorphismBeta).normalize(), point.y, point.z)
        var p2Neg = JacobianPoint(p2.x, p2.y.negate(1).normalize(), p2.z)

        // Flip the positive and negative values of the points as needed
        // depending on the signs of k1 and k2.  As mentioned in the equation
        // above, each of k1 and k2 are multiplied by the respective point.
        // Since -k * P is the same thing as k * -P, and the group law for
        // elliptic curves states that P(x, y) = -P(x, -y), it's faster and
        // simplifies the code to just make the point negative.
        if (signK1 == -1) {
            p1 = p1Neg.also { p1Neg = p1 }
        }
        if (signK2 == -1) {
            p2 = p2Neg.also { p2Neg = p2 }
        }

        // NAF versions of k1 and k2 should have a lot more zeros.
        //
        // The Pos version of the bytes contain the +1s and the Neg versions
        // contain the -1s.
        val k1NAF = naf(k1)
        val k2NAF = naf(k2)
        val k1PosNAF = k1NAF.pos
        val k1NegNAF = k1NAF.neg
        val k2PosNAF = k2NAF.pos
        val k2NegNAF = k2NAF.neg
        val k1Len = k1PosNAF.size
        val k2Len = k2PosNAF.size

        val m = max(k1Len, k2Len)

        var q = JacobianPoint.Zero

        // Add left-to-right using the NAF optimization.  See algorithm 3.77
        // from [GECC].  This should be faster overall since there will be a lot
        // more instances of 0, hence reducing the number of Jacobian additions
        // at the cost of 1 possible extra doubling.
        for (i in 0 until m) {
            // Since k1 and k2 are potentially different lengths and the calculation
            // is being done left to right, pad the front of the shorter one with
            // 0s.
            var k1BytePos: Byte = 0
            var k1ByteNeg: Byte = 0
            var k2BytePos: Byte = 0
            var k2ByteNeg: Byte = 0
            if (i >= m - k1Len) {
                k1BytePos = k1PosNAF[i - (m - k1Len)]
                k1ByteNeg = k1NegNAF[i - (m - k1Len)]
            }
            if (i >= m - k2Len) {
                k2BytePos = k2PosNAF[i - (m - k2Len)]
                k2ByteNeg = k2NegNAF[i - (m - k2Len)]
            }
            var mask = 1 shl 7
            for (bit in 7 downTo 0) {
                // Q = 2 * Q
                q = doubleNonConst(q)

                // Add or subtract the first point based on the signed digit of the
                // NAF representation of k1 at this bit position.
                //
                // +1: Q = Q + p1
                // -1: Q = Q - p1
                //  0: Q = Q (no change)
                if ((k1BytePos.toInt() and mask) == mask) {
                    q = addNonConst(q, p1)
                } else if ((k1ByteNeg.toInt() and mask) == mask) {
                    q = addNonConst(q, p1Neg)
                }

                // Add or subtract the second point based on the signed digit of the
                // NAF representation of k2 at this bit position.
                //
                // +1: Q = Q + p2
                // -1: Q = Q - p2
                //  0: Q = Q (no change)
                if ((k2BytePos.toInt() and mask) == mask) {
                    q = addNonConst(q, p2)
                } else if ((k2ByteNeg.toInt() and mask) == mask) {
                    q = addNonConst(q, p2Neg)
                }

                mask = mask shr 1
            }
        }
        return q
    }

    // ScalarBaseMultNonConst multiplies k*G where G is the base point of the group
    // and k is a big endian integer.  The result is stored in Jacobian coordinates
    // (x1, y1, z1).
    //
    // NOTE: The resulting point will be normalized.
    fun scalarBaseMultNonConst(k: ModNScalar): JacobianPoint {
        // Point Q = ∞ (point at infinity).
        var q = JacobianPoint.Zero

        // curve.bytePoints has all 256 byte points for each 8-bit window.  The
        // strategy is to add up the byte points.  This is best understood by
        // expressing k in base-256 which it already sort of is.  Each "digit" in
        // the 8-bit window can be looked up using bytePoints and added together.
        val kBytes = k.bytes()
        for ((i, byteVal) in kBytes.withIndex()) {
            val p = byte2dPoints[i][byteVal.toUByte().toInt()]
            q = addNonConst(q, JacobianPoint(p.x, p.y, FieldVal.One))
        }
        return q
    }

    // isOnCurve returns whether or not the affine point (x,y) is on the curve.
    fun isOnCurve(fx: FieldVal, fy: FieldVal): Boolean {
        // Elliptic curve equation for secp256k1 is: y^2 = x^3 + 7
        val y2 = fy.square().normalize()
        val result = ((fx.square() * fx) + 7).normalize()
        return y2 == result
    }

    // DecompressY attempts to calculate the Y coordinate for the given X coordinate
    // such that the result pair is a point on the secp256k1 curve.  It adjusts Y
    // based on the desired oddness and returns whether or not it was successful
    // since not all X coordinates are valid.
    //
    // The magnitude of the provided X coordinate field val must be a max of 8 for a
    // correct result.  The resulting Y field val will have a max magnitude of 2.
    fun decompressY(x: FieldVal, odd: Boolean): Tuple2<FieldVal, Boolean> {
        // The curve equation for secp256k1 is: y^2 = x^3 + 7.  Thus
        // y = +-sqrt(x^3 + 7).
        //
        // The x coordinate must be invalid if there is no square root for the
        // calculated rhs because it means the X coordinate is not for a point on
        // the curve.
        val x3PlusB = (x.square() * x) + 7
        val (resultY, hasSqrt) = x3PlusB.sqrt()
        if (!hasSqrt) {
            return Tuple(FieldVal.Zero, false)
        }
        val result = if (resultY.normalize().isOdd != odd) {
            -resultY
        } else {
            resultY
        }
        return Tuple(result, true)
    }

    private fun initS256BytePoints(): List<List<Jacobian2dPoint>> {
        val result = mutableListOf<List<Jacobian2dPoint>>()
        val decoder = Base64.getDecoder()
        try {
            val decode = decoder.decode(compressedBytePoints)
            ByteArrayInputStream(decode).use { input ->
                InflaterInputStream(input).use { gis ->
                    val buffer = ByteBuffer.wrap(gis.readAllBytes())
                    buffer.order(ByteOrder.LITTLE_ENDIAN)
                    for (byteNum in 0..31) {
                        // All points in this window.
                        val windowPoints = mutableListOf<Jacobian2dPoint>()
                        for (i in 0..255) {
                            windowPoints.add(
                                Jacobian2dPoint(
                                    loadFieldVal(buffer),
                                    loadFieldVal(buffer)
                                )
                            )
                        }
                        result.add(windowPoints)
                    }
                }
            }
        } catch (e: IOException) {
            logger.error(e) { "Could not read/decompress sec256k1points: " + e.message }
        }
        return result
    }

    private fun loadFieldVal(buffer: ByteBuffer): FieldVal {
        return FieldVal(buffer.int, buffer.int, buffer.int, buffer.int, buffer.int, buffer.int, buffer.int, buffer.int, buffer.int, buffer.int)
    }
}
